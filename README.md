# My Approach to Project 1

Before beginning the project I read through the code and documentation on the website on Project 1. I read through the given code to understand what the project goal was and how I should plan for the project. I researched and read up on C syntax to familiarize myself before diving into the project.

## Part 1
Before coding, I began to research ways to get user input in C with getline because getline malloc/reallocs accordingly from my understanding. I first coded the main function to validate no command line arguments were passed. Once I could correctly extract user input and free the pointer string correctly I moved on to the parsing command function. My approach to the parsing algorithm was to figure out a way to parse the commands in an effective and efficient way. I researched how to deep copy strings to store temp string pointers and I researched how to calloc and free memory to properly deal with the allocated memory from the unescape function. I spent a few days trying out different algorithms to parse and ultimately came up with one that loops based on the number of args expected (number of first unquoted spaces) this tells you how many args/iterations you should expect to have in the double pointer array. Once I figured out how to parse I spent some time figuring out how to free the memory from unescape after parsing. I figured out how to do this by creating a temp string pointer which holds the string you're currently at in the args array. This calls unescape on the string and then string copies it to the args array. This method is efficient because you can free all of the allocated memory in the loop and return the args with no memory leaks. After completing part 1, I still had a ton of memory leaks coming my input but mostly from parse so I decided to keep the code that worked and work on the memory leaks. I had to rewrite my parse function with a slight tweak in the implementation but with mostly the same algorithm. I ended up getting parse to work with no memory leaks so now there are no leaks coming from those functions.

## Part 2
After researching a ton for part 1 I was a lot more efficient in coding for part 2 of the project. I first started out by returning the arg array (string of strings) to the user loop to use string compare to compare the first argument of the passed array to either proc or exit. I decided to use a while loop to loop until the user entered exit with any arguments. For the exit function, the function checks how many arguments the user passed in with exit. If the number of arguments is 1 then it exits because that is simply exit with a code of 0. If the arguments are exactly 2 then it determines if the second argument is a digit, if it is not then it reprompts the user and frees memory. If the number of arguments is over 2 then it frees memory and reprompts the user. The proc command takes in the array and concatenates the strings using a temp string pointer like I have been using. It concatenates double slashes (/) into the string along with the argument at args[index]. To execute the proc command, it attempts to open the file and if it doesn't exist it frees memory and reprompts. If the file is successful then it reads the path line by line and displays it to the command line. After this function executes then free memory and continuously get the user input until the user enters exit. The execute command function takes in the parsed args array and forks a proccess. This process gets executed using execvp with the first argumnet of the parsed array and the array passed in. Once the fork finishes then free memory and get user input again. My idea here was to call each function and then free the memory to avoid memory leaks. I also initialized and declared a few helper functions. I have a free function which frees allocated memory and this gets calle after each command so there are no memory leaks when exiting. I also tested several edge cases when I finished the project to ensure edge cases were met.

## Sources:
* https://stackoverflow.com/questions/4035769/invalid-read-of-size-8-valgrind-c
* https://stackoverflow.com/questions/15622215/analyze-valgrind-output-invalid-free 
* https://c-for-dummies.com/blog/?p=1112
* https://www.tutorialspoint.com/c_standard_library/c_function_strncpy.htm
* https://www.tutorialspoint.com/c_standard_library/c_function_strncat.htm
* https://www.programiz.com/c-programming/c-dynamic-memory-allocation
* https://stackoverflow.com/questions/19990704/how-why-can-fork-fail
* https://www.csee.umbc.edu/courses/undergraduate/421/spring21/project1.html
* https://www.journaldev.com/40793/execvp-function-c-plus-plus
* https://stackoverflow.com/questions/26685936/valgrind-invalid-write-of-size-1-for-strcpy
